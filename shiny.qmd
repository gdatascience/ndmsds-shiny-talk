---
title: "Get Your Shiny On"
subtitle: "Turning R Code into Interactive Gold!"
date: "2024-12-05"
author: "Tony Galván"
title-slide-attributes: 
  data-notes: "Hi everyone! My name is Tony Galván, and I’m excited to share one of my favorite R tools with you today — Shiny. I’ve titled this session 'Get Your Shiny On: Turning R Code into Interactive Gold!' because Shiny has this amazing ability to transform static code into something dynamic and engaging. Whether you’re building dashboards, apps, or just experimenting with interactivity, Shiny opens up so many possibilities. We’ll keep it fun and hands-on, so by the end of this session, you’ll have the confidence to start building your own Shiny apps. Before we get started, let’s do a quick roll call. In the chat, could everyone share where they’re tuning in from? It’s always great to see the variety of locations represented in these sessions. Also, make sure you’ve got RStudio open and ready to go. This is going to be a hands-on session, and we’ll be coding together. Now, before we jump into the Shiny magic, let me tell you a little about myself."
format:
  revealjs: 
    theme: acorns.scss
    code-line-numbers: false
editor: visual
server: shiny
---

## Introduction <!-- slide_02 -->

### [University of Notre Dame]{style="color: #74c947"}

-   1999 B.B.A. Management Information Systems
-   2019 M.S. Data Science

![](images/graduation.jpg){fig-align="center"}

::: notes
You know, they say lightning doesn’t strike twice—but apparently, diplomas from Notre Dame do. I’m a proud Double Domer, having graduated not once, but twice. The first time was back in 1999 with a Bachelor of Business Administration in Management Information Systems, and then I made my triumphant return in 2019 to earn a Master of Science in Data Science.

On this slide, you’ll see two photos that are pretty special to me. The one from 1999 is with my dad—look at those fresh faces, full heads of hair, and zero wrinkles. The 2019 photo is a bit more… experienced. This time, I was lucky enough to share the day not just with my dad again, but also my wife and kids.

Notre Dame didn’t just give me degrees—it gave me a crash course in juggling deadlines, debugging code at 2 a.m., and still showing up to work the next morning ready to tackle the day. It’s also where I built the foundation in R, analytics, and machine learning that shaped my career.

And while Notre Dame couldn’t keep me young forever, it did teach me how to keep learning—and that’s what I’m here to share with you today.
:::

## Introduction (continued) <!-- slide_03 -->

::::: columns
::: {.column width="50%"}
### [Acorns]{style="color: #74c947"}

-   Data Analyst
-   Analytics Engineer

![](https://sqy7rm.media.zestyio.com/Acorns-Logo.svg){fig-align="center" height="200"}
:::

::: {.column width="50%"}
### [Tidy Tuesday]{style="color: #74c947"}

-   Tuesdays \@ 11AM PST on [Zoom](https://notredame.zoom.us/j/93246968828?pwd=T2k0QUFKNkxvMkV2ekZrejdpdTJIdz09)

![](https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/static/tt_logo.png){fig-align="center"}
:::
:::::

::: notes
So, what am I up to these days? Well, I work as an Analytics Engineer and Data Analyst at Acorns. My day-to-day involves wrangling data, building dashboards, and automating workflows. Basically, I’m a professional problem solver—except my puzzles occasionally yell at me in the form of cryptic error messages.

Outside of work, I run weekly Tidy Tuesday sessions. These are casual get-togethers where we take random datasets and try to uncover insights—or at least find a halfway decent visualization. It’s part data exploration, part group therapy for R users.

Tidy Tuesday is where I’ve really leveled up my data science game. It’s been a playground for learning, a laboratory for failed experiments, and a reminder that even the most boring datasets can shine with a little creativity. It’s also where I discovered that debugging is way more tolerable when someone else is suffering alongside you.

Today, I’m excited to share some of the lessons I’ve learned through work, Tidy Tuesday, and a whole lot of trial and error. Let’s jump in and see how Shiny can add a whole new dimension to your data science toolkit!
:::

## What is Shiny? <!-- slide_04 -->

```{r ShinyInstall}
#| echo: true
#| eval: false

install.packages("shiny")
```

::: notes
Alright, now that you know a bit about me, it’s time to focus on the real star of today’s show: Shiny!

Before we dive into the details, let me ask you a quick question: how familiar are you with Shiny? Drop your answer in the chat—are you a:

Shiny newbie (nothing at all),
Homework hero (just what we did for class),
Casual tinkerer (a little work experience),
Or a Shiny master (you eat reactive programming for breakfast)?
While you’re sharing, let’s make sure everyone’s ready to roll. Open up RStudio and install Shiny by running this code snippet:
install.packages("shiny")
:::

. . .

-   Transforms static R code into dynamic, interactive experiences
-   No need for HTML, CSS, or JavaScript
-   Reactive: Automatically updates outputs when inputs change

::: notes
So, what is Shiny? In a nutshell, it’s an R package that lets you build interactive web applications right from R. No HTML, CSS, or JavaScript knowledge required—it’s like a shortcut to web development greatness.

With Shiny, you can create dashboards, visualizations, and even full-fledged web apps. And the best part? It’s reactive, meaning your app automatically updates when inputs change. It’s like magic, but with fewer wands and more parentheses.

We’re going to get hands-on with Shiny today, and by the end of this session, you’ll be ready to build your own interactive masterpieces. So, what do you say—ready to get your Shiny on?
:::

## Anatomy of a Shiny App <!-- slide_05 --> {.smaller}

```{r ShinyCodeSnippet}
#| echo: true
#| eval: false

library(shiny)
ui <- ... # UI elements go here

server <- function(input, output) {
  ... # Server logic goes here
}

shinyApp(ui, server)
```

::: notes
Alright, we’ve got Shiny installed—congrats! You’re officially ready to build something awesome. But before we jump into coding, let’s break down the basic anatomy of a Shiny app. Think of it as a crash course in app biology.

First up, there are three main components:

UI (User Interface): This is like the shiny (pun intended) hotel lobby—it’s what users see and interact with. Buttons, sliders, and text boxes live here, welcoming your users like a charming front desk concierge.
Server: Behind the scenes, this is where the real magic happens. If the UI is the lobby, the server is the overworked hotel staff making sure the Wi-Fi, room service, and weirdly specific guest requests all work seamlessly.
shinyApp: This is the matchmaker that brings the UI and server together, turning your code into a fully functional app.
:::

. . .

```{r ShinyUIServer}
#| fig-align: center

library(tidyverse)
theme_set(theme_void(base_family = "Avenir Next"))

shiny_flow_df <- tibble(
  xmin = c(0, 10),
  xmax = c(5, 15),
  ymin = c(0, 0),
  ymax = c(10, 10),
  fill = c("UI", "Server")
)
shiny_flow_df |>
  ggplot() +
  geom_rect(
    aes(
      xmin = xmin,
      xmax = xmax,
      ymin = ymin,
      ymax = ymax,
      fill = fill
    ),
    show.legend = FALSE
  ) +
  geom_text(
    aes(
      x = (xmin + xmax) / 2,
      y = (ymin + ymax) / 2,
      label = fill
    ),
    family = "Avenir Next",
    color = "white",
    fontface = "bold",
    size = 20
  ) +
  geom_segment(
    aes(
      x = c(10, 5),
      xend = c(5, 10),
      y = c(3, 7),
      yend = c(3, 7)
    ),
    arrow = arrow(length = unit(0.5, "cm")),
    linewidth = 1.25,
    color = "white"
  ) +
  geom_text(
    aes(
      x = c(7.5, 7.5),
      y = c(3.75, 7.75),
      label = c("Output", "Input")
    ),
    family = "Avenir Next",
    color = "white",
    fontface = "bold",
    size = 8
  ) +
  scale_fill_manual(
    values = c("#9471f6", "#74c947")
  ) +
  theme(
    panel.background = element_rect(
      fill = "#363f41",
      color = "#363f41"
    )
  )
```

::: notes
Now, check out the diagram on the slide. It’s like the flowchart version of a rom-com:

Inputs from the UI go to the server. Imagine your user clicking a button or entering text—it’s like placing an order at a coffee shop.
Outputs flow back from the server to the UI. This is your latte (or chart, or table) being served in all its glory.
This back-and-forth makes Shiny apps reactive. The server is always listening for changes in inputs and updating the outputs, creating that smooth, interactive experience.

So how does all this magic work? When you run a Shiny app locally, it sets up a mini web server on your computer. Your machine becomes both the chef and the diner, cooking up data and serving it to yourself.

If you publish your app to a web server, things get fancier. The web server hosts your app, and anyone with an internet connection can use it. It’s like opening your own restaurant—except no health inspections.

So, are you ready to roll up your sleeves and build your first Shiny app? Let’s make some interactive magic happen!
:::

## Create a Shiny App <!-- slide_06 -->

::::: columns
::: {.column width="50%"}
File \> New File

-   Shiny Web App

![](images/clipboard-1611009231.png){fig-align="left" height="350"}
:::

::: {.column width="50%"}
Application name:

-   **old_faithful**

![](images/clipboard-4002331887.png){fig-align="center"}
:::
:::::

::: notes
Alright, it’s time to get our hands dirty and create our first Shiny app using R Studio. Follow these steps with me:

1.  Open R Studio.

2.  Go to the top menu and click on **File**.

3.  Select **New File** from the dropdown menu.

4.  Choose **Shiny Web App** from the options.

5.  A dialog box will appear. Enter the Application Name as **‘old_faithful’**.

6.  For Application Type, select **‘Single File (app.R)’**. This option is great for simple apps and is perfect for our first Shiny app.

7.  Click the **‘Browse’** button to choose the directory where you want to save your app.

8.  Click the **‘Create’** button.

And just like that, R Studio will generate a basic Shiny app template for you. This template includes a simple user interface and server logic that we can build upon.

Let’s take a moment to explore what R Studio has created for us. You'll see two main sections in the **‘app.R’** file: the UI and server components. The UI section defines the layout of the app, while the server section contains the logic to make the app interactive.

By following these steps, you’ve just created the foundation of your first Shiny app. Now, let’s dive into the code and start customizing it to make it our own!
:::

## Run the Shiny App

![](images/run_shiny.png){fig-align="center"}

::: notes
Now that we’ve created our first Shiny app, it’s time to see it in action! Here’s how you can run your Shiny app in R Studio:

In R Studio, locate the ‘Run App’ button, which is usually at the top right corner of the script editor. Click on the ‘Run App’ button. When you click this button, R Studio does something pretty cool behind the scenes. It sets up a local web server on your machine. This local server is what makes your Shiny app interactive and responsive.

Once the server is up and running, your app will launch in a new window. This window is where you can interact with your app, see the outputs, and test the functionality.

So, what’s happening behind the scenes? Here’s a quick rundown:

-   R Studio starts a local web server that hosts your Shiny app. This server handles all the communication between the UI and server components of your app.

-   As you interact with the app (e.g., entering data, clicking buttons), the server processes these inputs and updates the outputs in real-time.

-   The app runs in a web browser window, giving you a preview of how it will look and behave when deployed on a web server. By running your app locally, you can develop and test it before sharing it with others. It’s a great way to ensure everything works as expected and to make any necessary tweaks.

Ready to give it a try? Click that ‘Run App’ button and watch your Shiny app come to life!
:::

## Old Faithful Geyser Data <!-- slide_07 -->

```{r}
sliderInput("bins", "Number of bins:",
            min = 1, max = 50, value = 30)
plotOutput("distPlot")
```

```{r}
#| context: server
output$distPlot <- renderPlot({
  x <- faithful[, 2]
  bins <- seq(min(x), max(x), length.out = input$bins + 1)
  hist(x, breaks = bins, col = 'darkgray', border = 'white')
})
```

::: notes
Now that we’ve run our Shiny app, let’s take a closer look at what it does and how it works. Our app is a simple yet powerful example that visualizes the Old Faithful Geyser data. Here’s what you’ll see:

-   The app has a clear and descriptive title at the top: ‘Old Faithful Geyser Data’. This lets users know exactly what the app is about.

-   Below the title, there’s a slider input labeled ‘Number of bins’. This slider allows users to adjust the number of bins in the histogram. The range is from 1 to 50, with a default value set to 30. This interactivity lets users explore the data in different levels of granularity.

-   The main feature of the app is a histogram plot of the Old Faithful Geyser eruption durations. This plot is generated using base R graphics. As users adjust the slider, the histogram updates in real-time to reflect the new number of bins, providing an immediate visual feedback.

So, how does this all work together? When you move the slider, the input value is sent to the server. The server then recalculates the histogram with the specified number of bins and sends the updated plot back to the UI. This seamless interaction is what makes Shiny apps so engaging and dynamic.

By exploring this app, you can see how Shiny makes it easy to add interactivity to your data visualizations. It’s a great starting point for building more complex and customized applications.

Ready to build on this foundation and create something even more exciting? Let’s dive deeper into Shiny’s capabilities!
:::

## Shiny Layouts <!-- slide_08 -->

```{r ShinyLayouts}
#| echo: true
#| eval: false
#| code-line-numbers: "1-4,11"

fluidPage(
  titlePanel("Old Faithful Geyser Data"),
  sidebarLayout(
    sidebarPanel(
      sliderInput(
        inputId = "bins",
        label = "Number of bins:",
        ... # Other arguments (e.g., min, max, value)
      )
    ),
    mainPanel(
      plotOutput("distPlot")
    )
  )
)

```

[Shiny Layout Gallery](https://shiny.posit.co/r/layouts/)

::: notes
Let’s talk about the foundation of any Shiny app: the layout. A good layout isn’t just about looking pretty—it’s what makes your app intuitive and easy to use. If the layout is the stage, your data is the star, and Shiny helps set the scene beautifully.

The most popular layout in Shiny is fluidPage. It’s like the stretchy yoga pants of app design—it adapts effortlessly to different screen sizes, from desktops to mobile phones. Whether your users are on a giant monitor or squinting at their phone, fluidPage keeps your app looking sharp.

For apps that need tabs, navbarPage is a solid choice. It’s perfect for breaking down complex content into bite-sized, navigable pieces. If you’re designing an app with controls on the side—like sliders or input boxes—sidebarLayout is your go-to.

Take a look at this simple code snippet:

Line 1: fluidPage() is the main wrapper that defines a responsive, single-page layout. Everything you see in the app will live inside this.
Line 2: titlePanel() is the header—it’s like your app’s welcome mat, setting the tone with a title.
Line 3: sidebarLayout() creates the structure for a side panel and main content area. Think of it like a two-column newspaper: controls on one side, results on the other.
Line 4: Inside sidebarLayout(), sidebarPanel() is where the controls go—sliders, buttons, dropdowns, and anything your user interacts with.
Line 11: mainPanel() is for the main attraction—charts, tables, or whatever outputs your app is generating.
The magic of Shiny layouts is how flexible and intuitive they are. Not sure where to start? Check out Shiny’s layout gallery, which is packed with examples to spark your creativity.

And here’s the key takeaway: a thoughtful layout doesn’t just make your app look polished—it makes it more effective, drawing your audience into the story you’re telling with your data.

Now, let’s dive into the interactive elements that bring these layouts to life.
:::

## Shiny Widgets <!-- slide_09 -->

```{r ShinyUIWidgets}
#| echo: true
#| eval: false
#| code-line-numbers: "5-9"

fluidPage(
  titlePanel("Old Faithful Geyser Data"),
  sidebarLayout(
    sidebarPanel(
      sliderInput(
        inputId = "bins",
        label = "Number of bins:",
        ... # Other arguments (e.g., min, max, value)
      )
    ),
    mainPanel(
      plotOutput("distPlot")
    )
  )
)

```

[Shiny Widgets Gallery](https://shiny.posit.co/r/gallery/widgets/widget-gallery/)

::: notes
Once you’ve got your layout sorted, it’s time to make your app come alive with widgets. Widgets are the interactive elements that let your users explore, filter, and engage with your data. Think of them as the knobs, levers, and buttons of your app—simple to use but incredibly powerful.

Shiny offers a treasure trove of widgets. Here are a few crowd favorites:

sliderInput: Ideal for filtering data across a range. Need your users to zoom in on a specific slice of data? Sliders make it smooth and intuitive.
radioButtons: Perfect for when you want users to pick one option from a set—no room for fence-sitting here!
textInput: Allows users to enter custom text, whether it’s a search term, label, or a witty one-liner.
And, of course, dropdowns, checkboxes, and action buttons round out the collection to cover almost every need.
Let’s peek at a simple example:

Line 5: sliderInput is the widget itself. It sets up a slider to let users adjust the number of bins in a histogram, for instance.
inputId: This is the unique name you’ll use in your server code to refer to this widget.
label: What your user sees next to the slider—think of it as the slider’s name tag.
min, max, and value: These set the range of the slider and its starting position.
And the best part? Widgets don’t just sit there looking pretty—they’re fully reactive. When a user interacts with a widget, your Shiny app instantly updates outputs based on their input. This is what makes Shiny apps feel alive and responsive.

If you’re looking for inspiration or want to see the full range of widgets, check out Shiny’s widget gallery. It’s like a candy store for data scientists—packed with ideas and examples.

Here’s a pro tip: start simple. Use one or two widgets to explore your data and get comfortable with their behavior. Once you’ve got the hang of it, you can start layering on more complex interactions.

Speaking of getting comfortable, it’s time to roll up our sleeves and get hands-on. Let’s tackle a challenge and bring some widgets to life!
:::

## Old Faithful Geyser App <!-- slide_10 -->

### [Eruption Duration vs. Waiting Time]{style="color: #74c947"}

```{r}
#| panel: sidebar
sliderInput(
  "duration", 
  "Eruption Duration (minutes):",
  min = min(faithful$eruptions), 
  max = max(faithful$eruptions), 
  value = c(min(faithful$eruptions), max(faithful$eruptions))
)
sliderInput(
  "waiting", 
  "Waiting Time (minutes):",
  min = min(faithful$waiting), 
  max = max(faithful$waiting), 
  value = c(min(faithful$waiting), max(faithful$waiting))
)
```

```{r}
#| panel: fill
plotly::plotlyOutput("scatterPlot")
```

```{r}
#| context: server
library(plotly)
library(ggplot2)
library(dplyr)
output$scatterPlot <- 
  renderPlotly({
    ggplotly(
      faithful |>
        filter(
          eruptions >= input$duration[1],
          eruptions <= input$duration[2],
          waiting >= input$waiting[1],
          waiting <= input$waiting[2]
        ) |>
        ggplot(aes(x = eruptions, y = waiting)) +
        geom_point(
          color = "#74c947"
        ) +
        geom_smooth(
          method = "lm", formula = y ~ x,
          se = FALSE,
          color = "#9471f6",
          lty = 2
        ) +
        labs(
          x = "Eruption Duration (minutes)",
          y = "Waiting Time (minutes)"
        ) +
        theme_light() +
        theme(
          panel.background = element_rect(
            fill = "#363f41",
            color = "#363f41"
          ),
          panel.border = element_rect(
            color = "#363f41"
          ),
          plot.background = element_rect(
            fill = "#363f41",
            color = "#363f41"
          ),
          text = element_text(
            family = "Avenir Next",
            color = "white"
          ),
          axis.text = element_text(
            family = "Avenir Next",
            color = "white"
          ),
          panel.grid = element_blank(),
          axis.ticks = element_blank()
        )
    )
  })
```

::: notes
Alright, it’s time for a challenge! We’re going to take the default Old Faithful histogram app that comes with Shiny and transform it into something much more interactive and powerful.

Here’s the goal: adapt the default app to create an interactive scatter plot of the Old Faithful dataset, showing eruption durations on the x-axis and waiting times on the y-axis. We’ll be enhancing it with:

-   Sliders to filter values on both axes.
-   Plot interactivity using ggplot2 for visuals and Plotly for zooming, panning, and hovering.

Once your group gets the basics working, you can earn bonus points by tackling these advanced challenges:

1.  Add a dropdown: Allow users to choose a color for the points on the scatter plot.
2.  Dynamic title: Update the plot title based on the slider values.
3.  Summary table: Display average, minimum, and maximum values for the filtered data.
4.  Styling: Use custom CSS or themes to make the app look polished and professional.

We’ll break into small groups, and each group will work on adapting the default app into this enhanced version. I’ve included all the hints and documentation you’ll need, but feel free to ask me for help if you get stuck.

Remember, this is a creative and collaborative exercise. Even if you’re new to Shiny, give it a try and see how much progress your group can make.

At the end, we’ll come back together to showcase what you’ve built and discuss what you learned. Good luck—let’s get coding!
:::
